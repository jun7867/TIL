면접 준비도 할겸 Java 관련 면접 리스트를 정리해 보려고 합니다.

## Java의 장단점을 설명해라

### Java 장점
- 운영체제에 독립적이다. JVM에서 동작하기에 운영체제에 종속되지 않는다.
- 객체지향 언어이다. (캡슐화, 상속, 추상화, 다형성)
- 자동으로 메모리를 관리해준다. **Garbage Collector**
- 멀티스레드를 지원한다.
- **동적 로딩** (Dynamic loading)을 지원한다. 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 특정 클래스만 수정하면 되기에 전체를 컴파일하지 않아도 되며 유지보수시에 좋다.

### 단점
- 속도가 느리다. JVM에 의해 기계어 번역 과정을 거치기 떄문에 느리다. 
- 예외처리가 불편하다. 

### C/C++과의 차이점
- java는 객체지향, 컴파일하면 가상 운영체제인 JVM에서 실행가능한 바이트코드 형태의 클래스 파일이 생성되고, JVM을 통해 실행. 링크 과정없이 컴파일러가 바로 바이트 코드 생성. (운영체제가 바뀌어도 소스코드를 새로 작성하지 않아도 된다.) 

- C/C++은 절차지향, 소스를 컴파일하면 바로 실행될 수 있는 실행파일 생성. 컴파일러가 오브젝트 코드 생성 후, 라이브러리를 링크하여 최종 실행파일 생성.

### Java 동작
1. java 소스 파일을 javac로 컴파일 => class(바이트 코드) 생성
2. 클래스로더가 컴파일된 Java 바이트코드를 런타임 데이타 영역으로 로드
3. 실행 엔진이 자바 바이트코드 실행

### 객체지향 vs 절차지향
- 절차지향
: 실행하고자 하는 절차를 정하고 절차대로 프로그래밍, 일의 흐름에 중점.

- 객체지향
: 실제 물체를 객체로 표현하고, 이들의 관계, 상호 작용을 프로그램으로 나타낸다. 함수나 변수, 재활용성(하나의 클래스가 여러 개의 인스턴스가 될 수 있다)
=> 상속, 재사용성, 유지보수에 좋다, 코드 변경 용이

## call by value vs call by reference

### call by value
- 값에 의한 호출로 함수 호출 시 전달되는 변수의 메모리에 저장된 값을 복사해서 함수 인자로 전달한다. 따라서 함수 안에서 인자 값이 변경되더라도, 외부 변수 값은 변경되지 않는다. (local value)

### call by reference
- 참조에 의한 호출로 함수 호출 시 인자로 전달되는 변수의 reference를 전달한다. 따라서 함수 안 인자 값이 변경되면, 객체 값도 변경된다.

=> 자바의 경우 항상 **call by value**로 값을 넘긴다. (**reference는** **주소값을 복사함**). 객체를 메소드로 넘길 때 객체를 참조하는 지역변수의 실제 주소를 넘기는 것이 아니라 그 지역변수가 가리키고 있는 **힙 영역의 객체를 가리키는 새로운 지역변수를 생성**하여 같은 객체를 가리키도록 한다. 따라서 call by value만으로도 처리 가능하다.

### 장단점
Call by value의 경우, 데이터 값을 복사해서 함수로 전달하기 때문에 원본의 데이터가 변경될 가능성이 없다. 하지만 인자를 넘겨줄 때마다 메모리 공간을 할당해야해서 메모리 공간을 더 잡아먹는다.

Call by reference의 경우 메모리 공간 할당 문제는 해결했지만, 원본 값이 변경될 수 있다는 위험이 존재한다.

## OOP 특징 4가지
### 추상화(Abstraction)
- 객체에서 공통된 속성이나 기능을 추출하는 것. 중요하지 않은 것(관심 대상이 아닌 것)은 감추거나 무시하고, 중요한 것(관심있는 것)만을 강조하여 추출하는 것. 
- 관점에 따라 추상화의 결과가 달라질 수 있다. 주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다.

### 캡슐화(Encqpsulation)
- 정보은닉(필요없는 정보를 외부에서 접근하지 못하도록 제한하는것)
- 높은 응집도와 낮은 결합도를 유지시켜줌

### 상속(Inheritance)
- 부모의 형질을 이어받는다. 부모 클래스의 속성과 메소드를 그대로 사용할 수 있다. 
- 부모 속성에 새로운 속성을 추가해 Overriding을 통해 재정의 가능하다. 

### 다형성(Polymorphism)
- 서로 다른 클래스의 객체가 같은 메세지를 받았을때 각자 방식으로 동작


**Overriding**
임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 **메소드를 재정의 하여 사용**하는 것이다. 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.)

**Overloading**
메소드에 주어진 **인자(parameter)에 따라 동작을 다르게 구현**할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다.

## 인터페이스와 추상 클래스의 차이
### 추상 클래스와 인터페이스의 공통점
- new로 인스턴스(객체) 생성할 수 없다.
- 선언만 있고 구현 내용이 없다.
- 자식 클래스가 메서드의 구체적인 동작을 구현하도록 책임을 위임한다.
### 추상 클래스와 인터페이스의 차이점
- 서로 다른 목적을 가지고 있다.
- **추상 클래스**는 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는 데 목적이 있다. (**상속을 위한 부모 클래스**)
- **인터페이스**는 **서로 관련이 없는 클래스**에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다. (**구현 객체의 같은 동작을 보장**)
추상 클래스는 클래스이지만 인터페이스는 클래스가 아니다.
- 추상 클래스는 단일 상속이지만 인터페이스는 다중 상속이 가능하다.
추상 클래스는 “is a kind of” 인터페이스는 “can do this”
Ex) 추상 클래스: Appliances(Abstract Class) - TV, Refrigerator
Ex) 인터페이스: Flyable(Interface) - Plane, Bird

## Collection
- 자바의 대표 Collections에는 List,Map,Set,Stack, Queue와 같은 것들이 있다. collection을 사용하는 이유는 다수의 Data를 다루는데 표준화된 클래스들을 제공해주기 때문에 DS를 직접 구현하지 않아도 편하게 사용 가능.

### Map
검색할 수 있는 인터페이스
데이터를 삽입할 때 Key와 Value의 형태로 삽입되며, Key를 이용해서 Value를 얻을 수 있다.

- HashMap: key와 value로 이루어지고 중복을 허용하지 않으며 순서가 없다. O(1)

- TreeMap: Tree구조이기에 순서를 보장한다. O(logn)

- LinkedHashMap: LinkedList로 구현된 HashMap으로 List로 되어있기에 순서는 보장되나 랜덤접근에서는 느릴 수 있다. O(n)

###  List
순서가 있는 Collection, 데이터를 중복해서 포함할 수 있다. 구현 방법에 따라 ArrayList, LinkedList가 들어갈 수 있다.

- ArrayList: 자바의 Vector를 개선한, 배열로 구현된 List로 리스트의 연산 수행시간 속도는 배열과 같다. 데이터에 대한 인덱스를 가지고 있어 데이터 검색에 적합하다.

- LinkedList: 다음 노드의 주소를 기억하는 List로, 배열에 비해 삽입과 삭제가 간단하다. 탐색의 경우에는 처음부터 탐색하기 때문에 느리다. 

* Array vs ArrayList 
=> Array는 크기가 고정, Primitive type, Object 둘다 담을 수 있다. ArrayList는 크기가 동적이고 Object만 담을 수 있다. 

### Set
집합적인 개념의 Collection. 순서의 의미가 없다.
데이터를 중복해서 포함할 수 없다.

- HashSet : Key값이 없는 자료형. 순서 보장X, 중복허용 X, 해쉬 알고리즘을 사용하여 검색 속도가 빠르다. 

- TreeSet : 이진 탐색 트리 형태로 요소를 저장한다. 레드-블랙 트리로 구현되어 있다. 


### Stack , Queue

- stack: 나중에 들어온애를 먼저 뽑기

- Queue: 먼저 들어간애를 먼저 뽑기


## Generic
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여준다
+ Wrapper class? (Integer,Float,Boolean)

## 동기화 비동기화 
### 동기화(Syncronous)

한 자원에 동시에 접근하는 것 제한
순차적으로 진행
다음에 실행될 명령은 현재 실행 중인 명령 종료 시까지 대기 (대기시간 버퍼링 발생)
서버와 클라이언트가 주고 받는 것이 동시에 이루어지는 형태
시간적인 동기화가 필요한 곳에 많이 사용
ex. 현금인출기
Java에서 synchronized 키워드 사용
자바에서 멀티 스레드 접근 제한 키워드
메소드 단위, 블록 단위 적용 가능
단, 메소드 단위로 지정할 경우 메소드 전체에 lock이 걸리기 때문에 가능하면 블록 활용 (임계 영역은 작을 수록 좋음)
### 비동기화(Asyncronous)

현재 실행 중인 명령이 종료되지 않아도 다음 명령 실행 가능
Callback 함수를 통해 결과 확인
ex. Ajax, Thread


## Static vs Heap vs Stack
### (static) Data 영역
- static을 통해 생성된 정적멤버들은 Heap이 아닌 **_Static 영역_**에 할당된다. **Static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조**할 수 있는 장점이 있다.
단, Garbage Collector의 관리 영역 밖에 존재하기에 Static에 있으면 **프로그램 종료시까지 메모리가 할당된 채 존재**한다.!! 
- 전역 변수로 사용
=> 너무 남발하면 시스템 성능에 악영향을 준다.


### stack 영역
- 기본 자료형에 해당하는(int double byte long boolean)**지역변수의 데이터의 값**이 저장되는 공간. 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다.
- LIFO(Last in First out)의 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- Stack 메모리는 Thread당 하나씩 할당 된다. 

### Heap 영역
- 참조형(Reference Type)의 데이터 타입을 갖는 객체(인스턴스,Integer, String, ArrayList..), 배열 등은 Heap 영역에 저장된다.
- 변수(객체,객체변수, 참조변수)는 Stack 영역의 공간에서 실제 데이터가 저장된 Heap 영역의 참조값을(reference value, 해쉬코드, 주소값) new 연산자를 통해 리턴받는다.
- **실제 데이터를 갖고 있는 Heap 영역의 참조 값을 Stack 영역의 객체가 갖고 있다**. 리턴 받은 참조 값을 갖고 있는 객체를 통해서만 해당 인스턴스를 핸들 할 수 있다. 
- Heap에 저장된 데이터가 불필요하면 JVM(GC)에 의해 해제된다.
- Heap 영역은 Thread 개수와 상관없이 한개만 존재한다.

## this


## final
- 개념: 변수나 메서드 또는 클래스가 ‘변경 불가능’하도록 만든다.
- 원시(Primitive) 변수에 적용 시
 해당 변수의 값은 변경이 불가능하다.
- 참조(Reference) 변수에 적용 시
참조 변수가 힙(heap) 내의 다른 객체를 가리키도록 변경할 수 없다.
- 메서드에 적용 시
해당 메서드를 오버라이드할 수 없다.
- 클래스에 적용 시
해당 클래스의 하위 클래스를 정의할 수 없다.

![](https://images.velog.io/images/jun7867/post/bb419ee6-d735-4a38-bb35-b6d2559d9d54/image.png)

## 기타
### java에서 ‘==’와 ‘Equals()’의 차이
- == 연산자는 두개의 대상의 **주소값을 비교**
- equals는 비교 대상의 **값 자체를 비교.**

### 접근 제한자
Public – 접근 제한이 없다.(같은 프로젝트 내에 어디서든 사용 가능)

Protected – 같은 패키지 내, 다른 패키지에서 상속 받아 자손 클래스에서 접근 가능

Default – 같은 패키지 내에서만 접근 가능

Private – 같은 클래스 내에서만 접근 가능

### String과 StringBuffer 차이
- String은 객체. 불변이다. 문자를 수정하면 새로 생성. 기존은 GC에 의해 제거. => 연산이 빈번하면 힙 메모리에 임시 가비지가 생성되어 힙메모리 부족할 수도 있다.

StringBuffer/StringBuilder: 가변성. 동일 객체 내에서 문자열 변경 가능. StringBuffer는 동기화 지원(멀티쓰레드), StringBuilder는 동기화 지원하지 않기에 단일쓰레드에서 사용



### 동기화와 비동기화의 차이(Syncronous vs Asyncronous)
- 동기(Synchronous) 방식
요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
순서에 맞추어 진행되기 때문에 제어하기 쉽다.
여러가지 요청을 동시에 처리할 수 없어 효율이 떨어진다.
동기 방식의 예시로는 콜센터 종업원이 일을 처리하는 방식이 될 수 있다. 콜센터의 직원은 한 손님의 전화 응대가 끝난 후에 다음 손님의 응대를 진행할 수 있다.

- 비동기(Asynchronous) 방식
요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있다.
작업이 완료된 결과를 제어하기 어렵다.
비동기 방식의 예제로는 이메일이 있다. 우리는 한 사람에게 이메일을 보냈을 때 답변을 받지 않고도 이메일을 다시 보낼 수 있다. 


출처: https://mangkyu.tistory.com/88 [MangKyu's Diary]


### OOP 5대 원칙(SOLID)

### Garbage Collector
https://mangkyu.tistory.com/94
[테코톡 유튜브 강의](https://www.youtube.com/watch?v=vZRmCbl871I)
- 동적으로 할당한 메모리 영역(heap 영역) 중 사용하지 않는 영역을 탐지하여 해제하는 기능.

**Garbage Collector 과정**
1) Stack 영역의 모든 변수를 스캔하면서 어떤 객체를 참조하고 있는지 마킹한다. => Mark
2) 마킹한 객체(Reachable Object)가 참조하고 있는 객체도 찾아서 마킹한다. 연결-연결  => Mark
3) 마킹되지 않는 객체는 heap영역에서 제거한다. => Sweep 

> Q. 언제 Garbage Collector가 일어날까?
- 
![](https://images.velog.io/images/jun7867/post/5ea4c262-517c-403d-bbd5-ca4862a93f18/image.png)
- Eden 영역에 새로운 객체들이 할당되는데 Eden이 가득 차게 되면 GC가 발생한다. (Minor) Eden 영영의 Reachable 객체는 Survival 0으로 옮겨지고 Unreachable 객체는 메모리에서 해제된다.
- Survival 0영역도 가득차면 GC가 발생한다. 연결되어 남은 객체는 Survival 1로 이동한다. Age 증가.
- Survival 1도 가득차면 Survival 0으로 이동되고 Age가 증가한다. 
- 특정 Age값 이상이 되면 Old Generation으로 이동하게 되는데 이를 Promotion이라고 한다. Old도 가득 차면 GC 발생 (Major)

**Garbage Collector의 종류**
1) Serial GC
2) Parallel GC
3) Concurrent Mark Sweep GC
4) G1 GC

> 참고 링크
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java
https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md
https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-java.html
10분 테크톡



