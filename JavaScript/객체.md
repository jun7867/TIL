### 객체

- 자바스크립트는 객체기반의 프로그래밍 언어이다.
- 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향과 달리 다양한 객체 생성 방법을 지원한다. 
- 객체 리터럴, Object 생성자 함수, 생성자 함수, create 메서드, 클래스
- 객체 타입은 변경 가능한 값(mutable)이다.

### 객체 리터럴 ( {...})

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법이다.

객체 리터럴은 객체를 생성하기 위한 표기법이다. 

중괄호 {} 내에 0개 이상의 프로퍼티를 정의하면 객체가 생성된다.  객체 생성을 위해 클래스를 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다. 추후 프로퍼티를 포함시켜 동적으로 추가할 수 있다. 

```jsx
const person = {
	name: 'Kim',
	...
};
```

### 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다. 

프로퍼티는 . 혹은 []으로 접근하며 []로 접근할 때에는 ''로 key를 감싸줘야 한다. 아니면 식별자로 감지함.

ES6부터는 키와 값이 같다면 축약이 가능하다. 

---

## 11. 원시 값과 객체의 비교

원시값은 변경 불가능한 값(immutable)이고 객체는 변경 가능한 값(mutable)이다. 

원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 하지만 객체는 변수의 참조 값이 저장된다. 

원시 값은 다른 변수에 할당하면 값이 복사되고, 객체는 참조 값이 복사된다. (pass by reference)

### Immutable

- 변경 불가능하다는것은 변수가 아니라 값에 대한 것이다.
- 변수는 재할당을 통해 값을 변경할 수 있지만 원시 값 자체는 변경되지 않는 신뢰성을 보장한다.
- 변수가 값을 변경한다는 것은 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수가 새로운 원시 값을 가르키게 된다. 이떄 변수가 참조하던 메모리 공간의 주소가 바뀐다.
- 자바스크립트에서 문자열은 원시값이므로 값이 변경되지 않는다. ( 0번쨰 인덱스를 바꿔도 안바뀜)

### Pass by value

- 변수에 변수를 할당하면 해당 변수에 해당하는 값이 새로 생성되어 할당된다. 값이 복사됨. 원본의 값을 바꿔도 새로 생성되어 할당되었기 때문에 같이 바뀌지 않는다. 값은 같지만 별개의 메모리 공간에 저장됨.

```jsx
var a = 10;
var copy = a; // a와 같은 값이 새로운 메모리 공간에 생성
console.log(a===copy) // true
a=20;
console.log(a === copy) // false;
```

하지만, 실제로는 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 값을 참조할 수 있다.  

*자바스크립트에서 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블과 유사하다. 

### mutable

참조 값은 생성된 객체가 저장된 메모리 공간 그 자체다. 

객체는 변경 가능한 값으로 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이도 프로퍼티를 동적으로 추가하고 프로퍼티 값을 갱신할 수 있으며 프로퍼티 자체를 삭제할 수 있다. 

객체를 변경하는 비용은 크기 때문에 변경 가능하게 설계되었지만 여러 개의 식별자가 하나의 객체를 공유할 수 있는 부작용이 있다. 

### 얕은 복사, 깊은 복사

얕은 복사는 객체에 중첩되어 있는 객체의 참조 값을 복사하고(한 단계만 복사), 깊은 복사는 중첩되어 있는 객체까지 모두 복사하여 완전한 복사본을 만든다. 

```jsx
// 얕은 복사 (... 스프레드)
const A = {~~~}
const copy = {...A};
console.log(A === copy); // false;
console.log(A.x === copy.x); // true

// 깊은 복사
const copy2 = _.cloneDeep(A); 
console.log(A === copy2); // false;
console.log(A.x === copy2.x); // false
```

객체를 그냥 대입해서 할당하면 얕은 복사. 원시값을 그냥 대입해서 할당하면 깊은 복사. 

### pass by reference

얕은 복사를 하면 참조 값이 복사돼서 결국에는 같은 객체를 가르킨다. 하나가 바뀌면 영향을 받음.

---

### 함수

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출된다.

 함수는 객체이며 JS 함수는 일급 객체이다. 일급 객체는 함수를 값처럼 자유롭게 사용할 수 있다는 뜻이다. 

함수 선언문은 표현식이 아니라 문이고 함수 표현식은 표현식인 문이다. 

```jsx
var add = function foo (x,y) {...} // 표현식
add(2,3) // O
foo(2,3) // X 
```

함수 선언문만 호이스팅이 된다. 단, 변수 호이스팅과 다르게 undefined가 아니라 함수 객체로 초기화되어 호출하여 사용해도 된다. 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아니라 변수 호이스팅이 발생한다. 

### 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 이벤트 처리, Ajax 통신, 타이머 함수 등에서 사용됨.
